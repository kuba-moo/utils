/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 * Copyright (C) 2014 Jakub Kicinski <kubakici@wp.pl>
 */

/* Bigger tool which uses libpcap to read statistics generated by NetFPGA
 * from file or directly from the capturing interface and does calculations.
 */

#define _GNU_SOURCE 1

#include <assert.h>
#include <ctype.h>
#include <dirent.h>
#include <errno.h>
#include <pcap.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <inttypes.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <ccan/opt/opt.h>
#include <ccan/tal/tal.h>
#include <ccan/list/list.h>
#include <ccan/short_types/short_types.h>

#define FBOLD "\e[1m"
#define FNORM "\e[0m"

#define dbg(fmt...)  if (0) printf(fmt)
#define msg(fmt...)  if (g_msg) printf(fmt)
#define pinf(msg)    if (g_msg) printf(msg " [pair %u]\n", d->n_samples)
#define err(fmt...)  fprintf(stderr, fmt)
#define err_ret(fmt...) ({ err(fmt); 1; })
#define err_nret(fmt...) ({ err(fmt); NULL; })
#define perr_ret(msg) ({ perror(msg); 1; })
#define perr_nret(msg) ({ perror(msg); NULL; })

#define PCAP_CNT_INF		-1
#define PCAP_SNAPLEN_ALL	2048

#define us_to_clk(x) ((x)*1000/8)
#define clk_to_us(x) ((x)*8/1000)

bool g_msg = true;

struct {
	char *res_pfx;
	char *res_dir;
} args = {
	.res_dir = "./",
};

static struct opt_table opts[] = {
	OPT_WITH_ARG("-p|--pfx <prefix>", opt_set_charp, NULL,
		     &args.res_pfx, "read files from result dir with names <prefix>*"),
	OPT_WITH_ARG("-d|--res-dir <path>", opt_set_charp, NULL,
		     &args.res_dir, "look for result files in <path>, default ./"),
	OPT_WITHOUT_ARG("-q|--quiet", opt_set_invbool,
			&g_msg, "suppress text output"),
	OPT_ENDTABLE
};

struct result {
	uint32_t rx_ts;
	uint32_t tx_ts;
};

#define FR_N_RES 128

struct result_frame {
	struct result r[FR_N_RES];
	uint8_t key;
	uint64_t ts;
} __attribute__ ((packed));

struct list_head g_pkt_queue[2] = {
	LIST_HEAD_INIT(g_pkt_queue[0]),
	LIST_HEAD_INIT(g_pkt_queue[1])
};

struct enqueued_frame {
	struct list_node node;
	struct result_frame fr;
} __attribute__ ((packed));

struct delay {
	int n_samples;
	int n_notifs;

	pcap_t *pcap_; /* temporary pointer to pcap context */

	int trace_size_;
	u32 *traces[3];
};

struct delay_bank {
	struct delay **bank;
};

void delay_trace_grow(struct delay *d)
{
	int i;

	if (!d->trace_size_) {
		d->trace_size_ = 2048;
		for (i = 0; i < 3; i++)
			d->traces[i] = tal_arr(d, u32, d->trace_size_);
	} else {
		d->trace_size_ *= 2;
		for (i = 0; i < 3; i++)
			tal_resize(&d->traces[i], d->trace_size_);
	}
}

static inline void delay_push(struct delay *d, u32 t1, u32 t2, u32 t3)
{
	assert(d->trace_size_ >= d->n_samples);

	if (unlikely(d->trace_size_ == d->n_samples))
		delay_trace_grow(d);

	d->traces[0][d->n_samples] = t1;
	d->traces[1][d->n_samples] = t2;
	d->traces[2][d->n_samples] = t3;
	d->n_samples++;
}

void result_ntoh(struct result *r)
{
	r->rx_ts = ntohl(r->rx_ts);
	r->tx_ts = ntohl(r->tx_ts);
}

static inline int result_get_delta(const u32 rx_ts, const u32 tx_ts)
{
	uint64_t rx = rx_ts;
	uint64_t tx = tx_ts;
	int d;

	/* Fix wrap around - */
	if ((int)tx < 0)
		rx |= 1ULL << 32;
	d = rx - tx;

	return d;
}

void result_process_pair(struct delay *d,
			 const struct result *r1,
			 const struct result *r2,
			 u32 tx_ts)
{
	static int last_tx_ts;
	u32 d1, d2, min;

	if (tx_ts - last_tx_ts < 0x2300 && tx_ts - last_tx_ts > 0x1e00) {
		pinf("Fixup tx_ts");
		tx_ts ^= 0x1000;
	}
	last_tx_ts = tx_ts;

	d1 = result_get_delta(r1->rx_ts, tx_ts);
	d2 = result_get_delta(r2->rx_ts, tx_ts);

	if (d1 > d2)
		min = d2;
	else
		min = d1;

	delay_push(d, d1, d2, min);
}

void packet_cb(u_char *args, const struct pcap_pkthdr *header,
	       const u_char *packet)
{
	struct delay *d = (void *)args;
	u8 src, other;
	struct result_frame *fr = (void *)packet, *dut1, *dut2;
	struct enqueued_frame *ofr;
	int i;

	if (header->len != sizeof(*fr)) {
		err("Wrong sized packet: %d!\n", header->len);
		pcap_breakloop(d->pcap_);
		return;
	}

	src = fr->key & 1;
	other = src ^ 1;

	/* If other DUT's result isn't in yet, enqueue packet and wait. */
	if (list_empty(&g_pkt_queue[other])) {
		struct enqueued_frame *copy = malloc(sizeof(*copy));

		memcpy(&copy->fr, packet, header->len);

		if (!list_empty(&g_pkt_queue[src]))
			msg("Multi enqueue %u\n", d->n_samples/128);
		list_add_tail(&g_pkt_queue[src], &copy->node);

		return;
	}

	ofr = list_pop(&g_pkt_queue[other], struct enqueued_frame, node);

	dut1 = src ? fr : &ofr->fr;
	dut2 = other ? fr : &ofr->fr;
	if (dut1->key != 0x55 || dut2->key != 0xaa)
		pinf("Keys wrong!");
	for (i = 0; i < FR_N_RES; i++) {
		u32 tx_ts;
		const bool is_notif = !dut1->r[i].tx_ts || !dut2->r[i].tx_ts;

		result_ntoh(&dut1->r[i]);
		result_ntoh(&dut2->r[i]);

		tx_ts = dut1->r[i].tx_ts ?: dut2->r[i].tx_ts;
		if (is_notif) {
			d->n_notifs++;

			if (!dut1->r[i].tx_ts && !dut2->r[i].tx_ts) {
				pinf("Double skip!");
				goto cb_out;
			}
		}

		if (dut1->r[i].tx_ts != dut2->r[i].tx_ts && !is_notif) {
			pinf("Frame tx ts mismatch");
			pcap_breakloop(d->pcap_);
			goto cb_out;
		}
		result_process_pair(d, &dut1->r[i], &dut2->r[i], tx_ts);
	}

cb_out:
	free(ofr);
}

struct delay *read_delay(const char *fname)
{
	int res;
	struct delay *d;
	pcap_t *pcap_src = NULL;
	char errbuf[PCAP_ERRBUF_SIZE];

	msg("Loading file %s\n", fname);

	pcap_src = pcap_open_offline(fname, errbuf);
	if (!pcap_src)
		return err_nret("Could not load packets: %s\n", errbuf);

	d = talz(NULL, struct delay);
	d->pcap_ = pcap_src;

	res = pcap_loop(pcap_src, PCAP_CNT_INF, packet_cb, (void *)d);
	if (res) {
		/* Print pcap msg if break was due to internal pcap error. */
		if (res == -1)
			pcap_perror(pcap_src, "Error while reading packets");
		tal_free(d);
		d = NULL;
		goto out;
	}

	d->pcap_ = NULL;
	msg("\tLoaded %d samples, %d notifs\n", d->n_samples, d->n_notifs);

out:
	pcap_close(pcap_src);

	return d;
}

struct delay_bank *open_many(const char *dir, const char *pfx)
{
	DIR *d;
	struct dirent *ent;
	int pfx_len = strlen(pfx);
	char *cwd;
	int n_res = 0;
	struct delay_bank *rb;

	cwd = get_current_dir_name();
	if (!cwd)
		return perr_nret("Could not get current dir");
	if (chdir(dir))
		return perr_nret("Could not go to the result dir");

	d = opendir(".");
	if (!d)
		return perr_nret("Could not open the result dir");

	rb = talz(NULL, struct delay_bank);

	while ((ent = readdir(d))) {
		if (strncmp(ent->d_name, pfx, pfx_len))
			continue;

		if (rb->bank)
			tal_resize(&rb->bank, ++n_res);
		else
			rb->bank = tal_arr(rb, struct delay *, ++n_res);

		rb->bank[n_res - 1] = read_delay(ent->d_name);
		if (!rb->bank[n_res - 1]) {
			tal_free(rb);
			rb = NULL;
			break;
		}
		tal_steal(rb->bank, rb->bank[n_res - 1]);
	}

	closedir(d);

	chdir(cwd);
	free(cwd);

	return rb;
}

int main(int argc, char **argv)
{
	struct delay_bank *db;

	opt_register_table(opts, NULL);

	if (!opt_parse(&argc, argv, opt_log_stderr))
		return 1;

	opt_free_table();

	if (!args.res_pfx)
		return err_ret("Please specify result file name prefix\n");

	db = open_many(args.res_dir, args.res_pfx);
	if (!db)
		return 1;

	tal_free(db);

	tal_cleanup();

	return 0;
}
